
f: x -> (y: J(y))

(+1): (x: J(x)) -> (y: J(y-1))

(+): (x: J(x)) -> (y: I(y)) -> (z: J(z-y) && I(z-x))

let x: (>=0) = 1;
let y: (>=5) = 10;
let z: |z| {(>=)(z-5) && (>=)(z-0)} = x + y;
<=>

pdo! {
    a1 <- m1
    a2 <- m2
    a3 <- m3
    ret vec![a1, a2, a3]
}

m1.bind(move |a1| {
    let a1 = a1.clone;
    m2.bind(move |a2| {
        let a1 = a1.clone;
        let a2 = a2.clone;
        m3.bind(move |a3| {
            let a1 = a1.clone;
            let a2 = a2.clone;
            let a3 = a3.clone;
            ret(vec![a1, a2, a3])
        })
    })
})

ret_cl = fn(x: i32) -> (i32 -> i32) {
    fn(y: i32) -> i32 {
        x + y
    }
}

ret_cl = fn(x: i32) -> (i32 -> i32) {
    fn(y: i32) -> i32 {
        x + y
    }
}


# インタプリタ型に心が傾いている理由
クロージャとか部分適用の機能はLLVM-IR上でも何とか実装できそう。問題はそれ以上の機能。
RTTIやリフレクションという類の機能もほしいが、LLVMベースでは明らかに難しい。かといってJVMなどを用いるのも中途半端。
もちろん速度は欲しいけど、PythonやRみたいに対話実行ができることを最優先するならば、インタプリタ式が最善。

# それでもコンパイル型で行く理由
「実行時に至れり尽せりのオレオレ機能満載で楽しくプログラミング。速度は遅いがそれ以上のメリットがある」というコンセプトで行くというのなら、それすなわちRubyじゃね？Rubyでよくね？という問題がある。
当初の目的（新言語を作るきっかけ）を長いこと忘れていたが、やっと思い出した。OpenGLを高速に動かしたい、しかしC++のような複雑かつ負の遺産的な部分のある言語はちょっと…という思いがあった。
Haskellのglossはいいかもと思ったものの、サンクが溜まっていく言語仕様とOpenGLの性能を最大限発揮したいという目的があまりマッチしていなかった。
正格評価で性能のオーバーヘッドの少ないHaskellがあれば理想。
