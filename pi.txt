
f: x -> (y: J(y))

(+1): (x: J(x)) -> (y: J(y-1))

(+): (x: J(x)) -> (y: I(y)) -> (z: J(z-y) && I(z-x))

let x: (>=0) = 1;
let y: (>=5) = 10;
let z: |z| {(>=)(z-5) && (>=)(z-0)} = x + y;
<=>

pdo! {
    a1 <- m1
    a2 <- m2
    a3 <- m3
    ret vec![a1, a2, a3]
}

m1.bind(move |a1| {
    let a1 = a1.clone;
    m2.bind(move |a2| {
        let a1 = a1.clone;
        let a2 = a2.clone;
        m3.bind(move |a3| {
            let a1 = a1.clone;
            let a2 = a2.clone;
            let a3 = a3.clone;
            ret(vec![a1, a2, a3])
        })
    })
})

ret_cl = fn(x: i32) -> (i32 -> i32) {
    fn(y: i32) -> i32 {
        x + y
    }
}

ret_cl = fn(x: i32) -> (i32 -> i32) {
    fn(y: i32) -> i32 {
        x + y
    }
}
